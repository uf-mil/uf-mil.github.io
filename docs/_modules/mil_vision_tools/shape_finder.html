<!DOCTYPE html>
<!-- Some pieces of this template were used from https://github.com/Rapptz/discord.py/blob/master/docs/_templates/layout.html -->
<html>
    <head>
        <!-- HTML meta -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale: 1.0">
        <title>mil_vision_tools.shape_finder</title>
        <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
        <link rel="stylesheet" href="../../_static/codeblocks.css" type="text/css" />
        <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
        <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../searchindex.js" defer></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/custom.js"></script>
        <script src="../../_static/sidebar.js"></script>
        <script src="../../_static/lightdarkmode.js"></script>
        <link rel="shortcut icon" href="../../_static/mil_white.svg"/>
        <link rel="index" title="Index" href="../../genindex.html" />
        <link rel="search" title="Search" href="../../search.html" />
    </head>
    <body>
        <div class="main-grid">
            <header class="grid-item">
                <nav>
                    <a class="main-heading" href="../../index.html">Machine Intelligence Lab</a>
                    <div id="mil-light-dark-icon" onClick="rotateLightDark();">
                        <span class="material-icons" title=""></span>
                    </div>
                    <a href="https://github.com/uf-mil/mil" target="_blank"><img class="mil-svg" src="../../_static/github.svg" /></a>
                    <a href="https://mil.ufl.edu" target="_blank"><img class="mil-svg" src="../../_static/mil.svg" /></a>
                </nav>
            </header>
            <aside class="grid-item">
                <span id="hamburger-toggle">
                    <span class="material-icons">menu</span>
                </span>
                <div id="sidebar"><form id="search-form" role="search" class="search" action="../../search.html" method="get">
    <div class="search-wrapper">
        <input type="search" name="q" placeholder="Search documentation" />
        <button type="submit" onmousedown="searchBarClick(event, document.getElementById('search-form'));">
            <span class="material-icons">search</span>
        </button>
    </div>
</form>
<h3><a href="../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../welcome.html">Welcome to MIL!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mechanical/index.html">Mechanical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../electrical/index.html">Electrical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../software/index.html">Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subjugator/index.html">SubjuGator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../navigator/index.html">NaviGator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">Software Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subjugator/reference.html">Subjugator Software Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../navigator/reference.html">Navigator Software Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/design.html">Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infrastructure/index.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../culture.html">Culture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../branding.html">Branding</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testingprocedures.html">SubjuGator Testing Procedures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deprecated.html">Deprecated Projects</a></li>
</ul>

                </div>
            </aside>
            <main class="grid-item" role="main">
                
  <h1>Source code for mil_vision_tools.shape_finder</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">geometry_msgs.msg</span> <span class="kn">import</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">image_geometry</span> <span class="kn">import</span> <span class="n">PinholeCameraModel</span>
<span class="kn">from</span> <span class="nn">mil_ros_tools.msg_helpers</span> <span class="kn">import</span> <span class="n">numpy_to_polygon</span><span class="p">,</span> <span class="n">rosmsg_to_numpy</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Kevin Allen&quot;</span>


<div class="viewcode-block" id="RectFinder"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder">[docs]</a><span class="k">class</span> <span class="nc">RectFinder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Keeps a model of a rectangle in meters, providing utility functions</span>
<span class="sd">    to find 2D and 3D pose estimations of rectangles matching this model</span>
<span class="sd">    found in a computer vision program.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        length (float): The measurement of the longer side of the rectangle, in meters.</span>
<span class="sd">        width (float): The measurement of the shorter side of the rectangle, in meters.</span>
<span class="sd">        model_3D (np.ndarray): The internal model of the three-dimensional rectangle.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the internal model of the rectangle. If width &gt; length, the</span>
<span class="sd">        two will be reversed so that length is always the longer side.</span>

<span class="sd">        Args:</span>
<span class="sd">            length (float): The measurement of the longer side of the rectangle</span>
<span class="sd">                in meters.</span>
<span class="sd">            width (float): The measurement of the shorter side of the rectangle</span>
<span class="sd">                in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure length &gt;= width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">10000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="p">)</span>  <span class="c1"># Scale 2D model to maintain precision when converting to int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="n">scale</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="n">scale</span><span class="p">]],</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="RectFinder.from_polygon"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.from_polygon">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_polygon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">polygon</span><span class="p">:</span> <span class="n">Polygon</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RectFinder</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a RectFinder from a ``geometry_msgs/Polygon`` message.</span>

<span class="sd">        The length of the class becomes the range of x/y (whichever larger). The width</span>
<span class="sd">        becomes the range of x/y (whichever shorter).</span>

<span class="sd">        Args:</span>
<span class="sd">            polygon (:class:`~geometry_msgs.msg._Polygon.Polygon`): The polygon to construct</span>
<span class="sd">                the class from.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: The polygon parameter is not an instance of :class:`~geometry_msgs.msg._Polygon.Polygon`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            RectFinder: A new instance of the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">rosmsg_to_numpy</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># If it contains just one point, treat the x/y and length/width</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span></div>

<div class="viewcode-block" id="RectFinder.to_polygon"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.to_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">to_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``geometry_msgs/Polygon`` instance representing the four corners</span>
<span class="sd">        of the rectangle where all ``z = 0``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Polygon: A constructed message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy_to_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_3D</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectFinder.sort_corners"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.sort_corners">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sort_corners</span><span class="p">(</span><span class="n">rect</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">debug_image</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a contour of 4 points, returns the same 4 points sorted in a known way.</span>
<span class="sd">        Used so that indices of contour line up to that in model for cv2.solvePnp</span>

<span class="sd">        Args:</span>
<span class="sd">            rect (np.ndarray): An array representing the contour of 4 points.</span>
<span class="sd">            debug_image (Optional[bool]): If not None, puts a circle and text</span>
<span class="sd">                of the index in each corner.</span>

<span class="sd">        .. code-block::</span>

<span class="sd">            p[0] = Top left corner         0--1     1--------2</span>
<span class="sd">            p[1] = Top right corner        |  |  or |        |</span>
<span class="sd">            p[2] = Bottom right corner     |  |     0--------3</span>
<span class="sd">            p[3] = Bottom left corner      3--2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Credit to David Soto for this implementation.</span>
        <span class="c1"># Work with both (n, 1, 2) and (n, 2) shaped contour representations</span>
        <span class="k">if</span> <span class="n">rect</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
            <span class="n">rect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">rect</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s2">&quot;m10&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="s2">&quot;m00&quot;</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s2">&quot;m01&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="s2">&quot;m00&quot;</span><span class="p">])))</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="n">rect</span> <span class="o">-</span> <span class="n">centroid</span>
        <span class="n">atan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">vectors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vectors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">atan_indicies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">atan</span><span class="p">)</span>
        <span class="c1"># Sort by arctan formed by vector from centroid to each point</span>
        <span class="n">rect</span> <span class="o">=</span> <span class="n">rect</span><span class="p">[</span><span class="n">atan_indicies</span><span class="p">]</span>
        <span class="c1"># If rect is horizontal, correct indices as noted above</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rect</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
            <span class="n">rect</span> <span class="o">=</span> <span class="n">rect</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
        <span class="c1"># Print indices onto image if debug_image is given</span>
        <span class="k">if</span> <span class="n">debug_image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pixel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rect</span><span class="p">):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">debug_image</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span>
                    <span class="n">debug_image</span><span class="p">,</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                    <span class="n">center</span><span class="p">,</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SCRIPT_COMPLEX</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">rect</span></div>

<div class="viewcode-block" id="RectFinder.verify_contour"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.verify_contour">[docs]</a>    <span class="k">def</span> <span class="nf">verify_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numerical comparison between a contour and the perfect</span>
<span class="sd">        model of the rectangle. A perfectly matched contour returns 0.0.</span>

<span class="sd">        Useful for filtering contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">matchShapes</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectFinder.get_corners"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.get_corners">[docs]</a>    <span class="k">def</span> <span class="nf">get_corners</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">contour</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">debug_image</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon_range</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span>
        <span class="n">epsilon_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to find the 4 corners of a contour representing a quadrilateral.</span>

<span class="sd">        If the corners are found, it returns these 4 points sorted as described</span>
<span class="sd">        in :meth:`.sort_corners`. These corners can be used for :meth:`.get_pose_2D`</span>
<span class="sd">        and :meth:`.get_pose_3D`.</span>

<span class="sd">        If a 4 sided polygon cannot be approximated, returns ``None``.</span>

<span class="sd">        Args:</span>
<span class="sd">            contour (np.ndarray): The contour of the image.</span>
<span class="sd">            debug_image (Optional[bool]): If not ``None``, will draw corners with</span>
<span class="sd">                text for indexes onto image.</span>
<span class="sd">            epsilon_range (Tuple[float, float]): Tuple of two epsilon values (factor</span>
<span class="sd">                of contour arclength) to try for polygon approx.</span>
<span class="sd">            epsilon_step (float): How much to increment epsilon each time while</span>
<span class="sd">                iterating through epsilon_range.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[np.ndarray]: The array, if it can be approximated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Credit David Soto for idea to iterate through multiple epsilon values</span>
        <span class="n">arclength</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">arcLength</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">epsilon</span> <span class="o">&lt;=</span> <span class="n">epsilon_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">approxPolyDP</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">arclength</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_corners</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">debug_image</span><span class="o">=</span><span class="n">debug_image</span><span class="p">)</span>
            <span class="n">epsilon</span> <span class="o">+=</span> <span class="n">epsilon_step</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="RectFinder.get_pose_3D"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.get_pose_3D">[docs]</a>    <span class="k">def</span> <span class="nf">get_pose_3D</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">corners</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">intrinsics</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dist_coeffs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cam</span><span class="p">:</span> <span class="n">PinholeCameraModel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rectified</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the model of the object, the corresponding pixels in the image, and camera</span>
<span class="sd">        intrinsics to estimate a 3D pose of the object.</span>

<span class="sd">        Either ``cam`` and ``rectified`` must be provided, or ``intrinsics`` and ``dist_coeffs``.</span>

<span class="sd">        Args:</span>
<span class="sd">            corners (np.ndarray): 4x2 numpy array from :meth:`.get_corners` representing</span>
<span class="sd">                the 4 sorted corners in the image.</span>
<span class="sd">            cam (Optional[PinholeCameraModel]): The camera model.</span>
<span class="sd">            rectified (bool): If ``cam`` is set, set True if corners were found in an</span>
<span class="sd">               already rectified image (image_rect_color topic).</span>
<span class="sd">            instrinsics (np.ndarray): Camera intrinisic matrix.</span>
<span class="sd">            dist_coeffs (np.ndarray): Camera distortion coefficients.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[Any, Any]: Represents the translation and rotation vector between</span>
<span class="sd">            the camera and the object in meters/radians. Use cv2.Rodrigues to convert</span>
<span class="sd">            ``rvec`` to a 3x3 rotation matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="c1"># Use camera intrinsics and knowledge of marker&#39;s real dimensions to</span>
        <span class="c1"># get a pose estimate in camera frame</span>
        <span class="k">if</span> <span class="n">cam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">intrinsics</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">intrinsicMatrix</span><span class="p">()</span>
            <span class="n">dist_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">if</span> <span class="n">rectified</span> <span class="k">else</span> <span class="n">cam</span><span class="o">.</span><span class="n">distortionCoeffs</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">intrinsics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">dist_coeffs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">rvec</span><span class="p">,</span> <span class="n">tvec</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">solvePnP</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_3D</span><span class="p">,</span> <span class="n">corners</span><span class="p">,</span> <span class="n">intrinsics</span><span class="p">,</span> <span class="n">dist_coeffs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">tvec</span><span class="p">,</span> <span class="n">rvec</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectFinder.get_pose_2D"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.get_pose_2D">[docs]</a>    <span class="k">def</span> <span class="nf">get_pose_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corners</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the 2D center of the rectangle and a unit direction vector along the length</span>
<span class="sd">        of the rectangle in pixels....</span>

<span class="sd">        Args:</span>
<span class="sd">            corners (np.ndarray): 4x2 numpy array from :meth:`.get_corners` representing</span>
<span class="sd">            the 4 sorted corners in the image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[Any, Any]: A tuple representing ``(center, vector)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">top_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">corners</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">bot_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">corners</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">top_center</span> <span class="o">-</span> <span class="n">bot_center</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">bot_center</span> <span class="o">+</span> <span class="p">(</span><span class="n">top_center</span> <span class="o">-</span> <span class="n">bot_center</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">top_center</span> <span class="o">-</span> <span class="n">bot_center</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectFinder.draw_model"><a class="viewcode-back" href="../../reference/vision.html#mil_vision_tools.RectFinder.draw_model">[docs]</a>    <span class="k">def</span> <span class="nf">draw_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span>
        <span class="n">border</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 1 channel image displaying the internal model of the rectangle.</span>
<span class="sd">        Useful for visually checking that your model is reasonable. Also useful</span>
<span class="sd">        to see what orientation of a contour will be considered 0 rotation in :meth:`.get_pose_3D`.</span>

<span class="sd">        Args:</span>
<span class="sd">            size (Tuple[int, int]): A 2 element tuple of ``(x, y)``, which will</span>
<span class="sd">                be the resolution of the returned image.</span>
<span class="sd">            border (int): Size of the border, in pixels, around the model</span>
<span class="sd">                contour in the returned image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: A one channel image with shape specified by size param with internal model</span>
<span class="sd">            drawn in white surrounded by a black border</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">border</span> <span class="o">+</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">border</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">drawContours</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">[</span><span class="n">model</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span></div></div>


<span class="k">class</span> <span class="nc">EllipseFinder</span><span class="p">(</span><span class="n">RectFinder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to test contours in images for being close to an ellipse</span>
<span class="sd">    matching a given model. Uses RectFinder on well matched</span>
<span class="sd">    contours to get 3D pose estimates.</span>

<span class="sd">    Can be used just as RectFinder is used, but contours passed to verify_contour</span>
<span class="sd">    will be evaluated based on their similarity to an ellipse, not a rectangle.</span>
<span class="sd">    The get_corners function will return the corners of the least area rotated</span>
<span class="sd">    rectangle around the ellipse contour, so 3D pose estimation will still work.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create internal model for an ellipse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

        <span class="c1"># Correct 2D model to be an oval to that verify_contour works</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="c1"># Approximate an ellipse with 50 points, so that verify_contour is reasonable fast still</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                <span class="mi">0</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_2D</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span>
                <span class="mi">1</span>
            <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_corners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour</span><span class="p">,</span> <span class="n">debug_image</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override get corner function for Ellipses to approximate an ellipse</span>
<span class="sd">        instead of a four sided polygon around the contour.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ellipse</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">fitEllipse</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">boxPoints</span><span class="p">(</span><span class="n">ellipse</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_corners</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">debug_image</span><span class="o">=</span><span class="n">debug_image</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CircleFinder</span><span class="p">(</span><span class="n">EllipseFinder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cute abstraction for circles, which are just ellipses with the same</span>
<span class="sd">    length and width. See EllipseFinder for usage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">radius</span><span class="p">)</span>
</pre></div>

            </main>
        </div>
    </body>
</html>